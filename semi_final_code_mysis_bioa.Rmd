---
title: "final_script_mysis_density_biosonics"
author: "Daniel Crownover"
date: "2025-07-15"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#### create, sample data from origional biosonics data:

### there is sample sv amp but I don't know if I should use that or create my own

## is the max depth correct?











#### plot per filter and check if its right

## plot for 

svamp <- read.csv("C:/Users/dancr/Downloads/dan_biosonics/20190529_231348_amp30LogR_X1.csv", header = FALSE)
n_bins <- nrow(svamp)

# Recreate depth bins (assume linear from surface to max depth)
max_depth <- 150  # meters
sample_range <- seq(0, max_depth, length.out = n_bins)

# Optional: apply topcut to remove surface noise above 3 m
topcut <- 3
sample_range_trimmed <- sample_range[sample_range > topcut]

# Save the full sample range to CSV
write.csv(sample_range, "20190529_231348_sampleRange_X1.csv", row.names = FALSE)

# Optional: also save trimmed version if you plan to use that separately
write.csv(sample_range_trimmed, "20190529_231348_sampleRange_trimmed_X1.csv", row.names = FALSE)



```


```{r}
##create Sv filtered file and save to computer

library(EBImage)



# setting the Parameters
topcut  <- 3        # meters, remove surface noise above this depth
bot     <- 55       # assumed bottom depth (meters)
calcor  <- 0.3      # calibration correction in dB
mysisTS <- -86.9    # mysis target strength in dB (not used here, but ready)
fish    <- -60      # fish signal threshold
save1   <- 0        # 1 to save filtered results, 0 to skip
filesdir <- "bioa_regular_data_xl1"  # your directory










### below setting exact file paths

# Exact paths
sv_file <- "C:/Users/dancr/Downloads/dan_biosonics/20190529_231348_ampEL_X1.csv"
sample_file <- "C:/Users/dancr/Downloads/dan_biosonics/20190529_231348_sampleRange_trimmed_X1.csv"
out_file <- "C:/Users/dancr/Downloads/dan_biosonics/20190529_231348_SvFilt.csv"

# Read in the data
svamp <- as.matrix(read.csv(sv_file, header = FALSE))
mode(svamp) <- "numeric"
sample_range <- read.csv(sample_file, header = TRUE)[[1]]

# Filtering for topcut and against the sample range
Sv_filt <- matrix(NA, nrow = nrow(svamp), ncol = ncol(svamp))
Sv_filt2 <- matrix(NA, nrow = nrow(svamp), ncol = ncol(svamp))

for (i in seq_len(ncol(svamp))) {
  f1 <- which(!is.na(svamp[, i]) & svamp[, i] != 0)
  Sv_filt[f1, i] <- svamp[f1, i]

  f2 <- which(sample_range > topcut & sample_range < bot)
  Sv_filt2[f2, i] <- Sv_filt[f2, i]
}

# Calibration correction
Sv <- Sv_filt2
Sv[Sv == 0] <- NA
Sv <- Sv + calcor

# Save to file
write.csv(Sv, out_file, row.names = FALSE)
cat("Saved:", out_file, "\n")


```

```{r}

### filter the data

# Ensure EBImage is loaded for morphological filtering
library(EBImage)

# Use last `Sv` matrix or load a filtered file
Sv <- as.matrix(read.csv("C:/Users/dancr/Downloads/dan_biosonics/20190529_231348_SvFilt.csv"))

# Define supporting variables
deps <- sample_range  # depth vector
cellH <- max(deps) / length(deps)
n <- ncol(Sv)
pings <- seq_len(n)

# Apply additional filtering
Sv[Sv == 0] <- NA
Sv <- Sv + calcor

# Morphological filtering
cellremove <- ceiling(0.7 / cellH)
Tsm <- matrix(1, nrow = cellremove, ncol = 1)

FET <- Sv
FET[FET > fish] <- NA
FET <- is.na(FET)

FET <- dilate(FET, Tsm)
FET <- dilate(FET, matrix(1, nrow = 2, ncol = 2))
FET <- !FET

Sv <- FET * Sv
Sv[Sv == 0] <- NA

# Filter top water layer (above thermocline)
topchopdepth <- ceiling(topcut / cellH)
Sv[1:topchopdepth, ] <- NA

# Save comparison matrix if needed
Svcompare <- Sv_filt2  # only valid if Sv_filt2 still exists

# Convert to linear units
Sv2 <- 10^(Sv / 10)

# Remove system noise floor
minnoise <- min(Sv, na.rm = TRUE)
Sv2 <- Sv2 - 10^(minnoise / 10)

# Calculate densities
sigbs <- 10^(mysisTS / 10)
density <- Sv2 / sigbs
beamdensity <- density / (deps * 2 * tanpi(3.3 / 180))  # convert 3.3° to radians
sump <- colSums(beamdensity, na.rm = TRUE)

avgdensity <- sump / (bot / cellH)
mysisarea <- avgdensity * (bot - topcut)
mysisarea[is.na(mysisarea)] <- 0
areasdev <- sd(mysisarea, na.rm = TRUE)

# Rotate density to plot
mysisarea_rot <- t(apply(matrix(mysisarea, nrow = 1), 2, rev))
hden <- rowMeans(beamdensity, na.rm = TRUE)

# Clean NA's by replacing with zero (or you can choose other method)
beamdensity_noNA <- beamdensity
beamdensity_noNA[is.na(beamdensity_noNA)] <- 0

# Define depth edges for plotting - length = number of depth bins + 1
deps_ext <- seq(0, 60, length.out = nrow(beamdensity_noNA) + 1)

# Define ping edges for plotting - length = number of pings + 1
pings_ext <- seq(1, ncol(beamdensity_noNA) + 1)

# Because image() expects z matrix with dim = (length(x)-1) x (length(y)-1),
# and x is pings, y is depths, we need to transpose beamdensity_noNA 
# so rows correspond to pings and columns to depths.

# Transpose beamdensity_noNA for correct orientation in plot
z_matrix <- t(beamdensity_noNA)  # dimensions: pings x depths

# Now plot using image()
image(x = pings_ext, y = deps_ext, z = z_matrix,
      col = heat.colors(100), zlim = c(0, 3),
      xlab = "Ping", ylab = "Depth (m)", main = "Mysis Density Snapshot")




### length must equal

```
```{r}
library(fields)  # for image.plot

beamdensity_noNA <- beamdensity
beamdensity_noNA[is.na(beamdensity_noNA)] <- 0

# Depth edges for image: length = rows + 1
deps_ext <- seq(0, 60, length.out = nrow(beamdensity_noNA) + 1)

# Ping edges for image: from 0 to 500 (length = cols + 1)
pings_ext <- seq(0, 500, length.out = ncol(beamdensity_noNA) + 1)

# Transpose so rows = pings, cols = depths
z_matrix <- t(beamdensity_noNA)  # dims: pings x depths

# Reverse blue palette: darker blue (lowest) to lighter blue (highest)
blue_palette_rev <- rev(colorRampPalette(c("lightblue", "blue"))(100))

# Plot with image.plot for legend, invert y-axis with ylim reversed
image.plot(x = pings_ext, y = deps_ext, z = z_matrix,
           col = blue_palette_rev, zlim = c(0, 3),
           xlab = "Ping", ylab = "Depth (m)", main = "Mysis Density Snapshot",
           ylim = rev(range(deps_ext)))


### MAKE A key of heat map values also make it blue with lighter colors representing mysis
```


```{r}


# Suppose depth bins go from 0 to 60 meters, 406 depth intervals
deps_ext <- seq(0, 60, length.out = 406 + 1)  # length = 407

# Suppose 50 pings, so edges 1 to 51
pings_ext <- 1:51                             # length = 51

# Your beamdensity matrix: depth × ping, expected 406 rows × 50 cols
# Replace this with your actual matrix:
# beamdensity <- YOUR_DATA_HERE

# For example, create dummy data for testing:
# beamdensity <- matrix(runif(406*50, min=0, max=3), nrow=406, ncol=50)

# Check dimensions and NA values
cat("dim(beamdensity):", dim(beamdensity), "\n")
cat("NAs in beamdensity:", sum(is.na(beamdensity)), "\n")

# Replace NA with 0 (or any suitable fill value)
beamdensity_noNA <- beamdensity
beamdensity_noNA[is.na(beamdensity_noNA)] <- 0

# Confirm dimensions match what image() needs:
expected_rows <- length(deps_ext) - 1  # 406
expected_cols <- length(pings_ext) - 1 # 50

cat("Expected rows for z:", expected_rows, "\n")
cat("Expected cols for z:", expected_cols, "\n")
cat("Actual rows in beamdensity_noNA:", nrow(beamdensity_noNA), "\n")
cat("Actual cols in beamdensity_noNA:", ncol(beamdensity_noNA), "\n")

# Trim or pad beamdensity_noNA if necessary
if (nrow(beamdensity_noNA) > expected_rows) {
  beamdensity_noNA <- beamdensity_noNA[1:expected_rows, , drop=FALSE]
}
if (ncol(beamdensity_noNA) > expected_cols) {
  beamdensity_noNA <- beamdensity_noNA[, 1:expected_cols, drop=FALSE]
}

if (nrow(beamdensity_noNA) < expected_rows | ncol(beamdensity_noNA) < expected_cols) {
  stop("beamdensity matrix is smaller than expected dimensions - fix your data!")
}

# Now plot image with correct dimensions and axis labels:
image(x = pings_ext, y = deps_ext, z = beamdensity_noNA,
      col = heat.colors(100), zlim = c(0, 3),
      xlab = "Ping", ylab = "Depth (m)", main = "Mysis Density Snapshot")


```


```{r}
# ---------------------------------------------
# Plot: Sv with only bottom removed
# This figure shows backscatter intensity (Sv) vs depth and ping number
# using the Sv_filt2 matrix, which has removed values below the bottom depth.
# ---------------------------------------------

cat("Length pings_ext (x):", length(pings_ext), "\n")
cat("Length deps_ext (y):", length(deps_ext), "\n")
cat("Dim beamdensity_noNA:", dim(beamdensity_noNA), "\n")

cat("Expected z rows (length(deps_ext)-1):", length(deps_ext)-1, "\n")
cat("Expected z cols (length(pings_ext)-1):", length(pings_ext)-1, "\n")



if (!all(dim(beamdensity_noNA) == c(length(deps_ext) - 1, length(pings_ext) - 1))) {
  stop("Dimension mismatch! z dimensions do not equal (length(y)-1) x (length(x)-1)")
}


# Force beamdensity to match required dims:
beamdensity_fixed <- beamdensity_noNA[1:(length(deps_ext)-1), 1:(length(pings_ext)-1)]

cat("Using beamdensity_fixed with dims:", dim(beamdensity_fixed), "\n")

image(x = pings_ext, y = deps_ext, z = beamdensity_fixed,
      col = heat.colors(100), zlim = c(0, 3),
      xlab = "Ping", ylab = "Depth (m)", main = "Mysis Density Snapshot")

























# 1. Trim depth vector to remove non-finite values (e.g., NA)
deps_trim <- deps[is.finite(deps)]

# 2. Trim Sv_filt2 rows to match the valid depth range
Sv_filt2 <- Sv_filt2[1:length(deps_trim), , drop = FALSE]

# 3. Compute spacing (dy) and extend the depth axis for correct image() dimensions
dy <- mean(diff(deps_trim), na.rm = TRUE)
deps_ext <- c(deps_trim, tail(deps_trim, 1) + dy)

# 4. Validation checks to avoid image() errors
stopifnot(length(deps_ext) == nrow(Sv_filt2) + 1)
stopifnot(all(is.finite(deps_ext)))

# 5. Plot the image of Sv_filt2 (after bottom removed)
image(
  x = pings_ext,                  # Ping number (x-axis)
  y = deps_ext,                   # Depths with extended edge (y-axis)
  z = t(Sv_filt2),                # Transposed matrix for image()
  col = gray.colors(100),        # Color scale: grayscale
  zlim = c(-100, -70),           # dB range for Sv visualization
  xlab = "Ping",                 # X-axis label
  ylab = "Depth (m)",            # Y-axis label
  main = "Sv with only bottom removed"  # Title
)


```

```{r}

# Trim Sv to valid depths
Sv <- Sv[1:length(deps_trim), , drop = FALSE]

# Rebuild deps_ext after trimming
dy <- mean(diff(deps_trim), na.rm = TRUE)
deps_ext <- c(deps_trim, tail(deps_trim, 1) + dy)

# Rebuild pings_ext if needed
dx <- mean(diff(pings))
pings_ext <- c(pings, tail(pings, 1) + dx)

# Check dimensions
stopifnot(nrow(Sv) == length(deps_trim))             # rows of z
stopifnot(ncol(Sv) == length(pings))                 # columns of z
stopifnot(length(deps_ext) == nrow(Sv) + 1)
stopifnot(length(pings_ext) == ncol(Sv) + 1)



image(
  x = pings_ext,
  y = deps_ext,
  z = t(Sv),
  col = gray.colors(100),
  zlim = c(-100, -70),
  xlab = "Ping",
  ylab = "Depth (m)",
  main = "Sv with top and bottom removed"
)



```

```{r}

length(hden)
length(deps_trim)


min_len <- min(length(hden), length(deps_trim))
hden <- hden[1:min_len]
deps_trim <- deps_trim[1:min_len]







# Split plotting space: left = echogram, right = profile
layout(matrix(c(1, 1, 1, 1, 1, 2), nrow = 1))

# Left panel: Echogram of mysis density
image(
  x = pings_ext,
  y = deps_ext,
  z = t(beamdensity),
  col = heat.colors(100),
  zlim = c(0, 3),
  xlab = "Ping",
  ylab = "Depth (m)",
  main = "Mysis Buoy Survey"
)

# Overlay lines: bottom and thermocline
abline(h = bot, col = "black")  # Bottom depth
abline(h = T, col = "black", lwd = 2)  # Thermocline

# --- Right panel: Vertical profile of density ---

# Ensure hden and deps_trim are same length
min_len <- min(length(hden), length(deps_trim))
hden <- hden[1:min_len]
deps_trim <- deps_trim[1:min_len]

# Right panel: Density profile vs depth
plot(
  hden, deps_trim,
  type = "l", col = "blue",
  xlim = c(0, 10),
  ylim = c(150, 0),  # reverse y-axis
  xlab = "Mysis / m³",
  ylab = "Depth (m)",
  main = "Average Density with Depth"
)
abline(h = T, col = "black", lwd = 2)


```

```{r}
plot(mysisarea, type = "l", col = "red", main = "Mysis / m²", ylab = "Mysis Area", xlab = "Ping Index")
# Optional standard deviation bounds
# lines(mysisarea - areasdev, col = "blue", lty = 2)
# lines(mysisarea + areasdev, col = "blue", lty = 2)

```
```{r}
# Trim depth (y) axis to match FET matrix
deps_trim <- deps_trim[1:nrow(FET)]
dy <- mean(diff(deps_trim), na.rm = TRUE)
deps_ext <- c(deps_trim, tail(deps_trim, 1) + dy)

# Trim pings (x) axis if needed
pings <- pings[1:ncol(FET)]
dx <- mean(diff(pings), na.rm = TRUE)
pings_ext <- c(pings, tail(pings, 1) + dx)

# Check match
# Remove non-finite values from pings_ext and deps_ext
pings_ext <- pings_ext[is.finite(pings_ext)]
deps_ext  <- deps_ext[is.finite(deps_ext)]




# Check sizes
cat("nrow(FET):", nrow(FET), "\n")
cat("length(deps_ext):", length(deps_ext), "\n")

# If FET has more rows than needed, trim it:
if (nrow(FET) > length(deps_ext) - 1) {
  FET <- FET[1:(length(deps_ext) - 1), , drop = FALSE]
}

# Or if FET has fewer rows, trim deps_ext
if (nrow(FET) < length(deps_ext) - 1) {
  deps_ext <- deps_ext[1:(nrow(FET) + 1)]
}
stopifnot(nrow(FET) == length(deps_ext) - 1)



image(
  x = pings_ext,
  y = deps_ext,
  z = t(FET),
  col = gray.colors(2),
  main = "FET Mask",
  xlab = "Ping",
  ylab = "Depth (m)"
)




```



```{r}
library(ggplot2)

# Create a dataframe for plotting points
df_density <- expand.grid(Ping = pings, Depth = deps)

# Flatten density matrix into vector, matching the expand.grid order

length(pings)     # say this is Np
length(deps)      # say this is Nd
dim(density)      # should be Nd x Np (rows = depth, cols = pings)
density_trim <- density[1:length(deps), ]

df_density <- expand.grid(Ping = pings, Depth = deps)
df_density$Density <- as.vector(density_trim)

# Remove NAs or zero/invalid densities if needed
df_density <- df_density[!is.na(df_density$Density) & df_density$Density > 0, ]

# Scatter plot of density points colored by density magnitude
scatter1<-ggplot(df_density, aes(x = Ping, y = Depth, color = Density)) +
  geom_point(alpha = 0.6, size = 1) +    # dots with some transparency
  scale_y_reverse() +                     # depth downward
  scale_color_viridis_c(option = "plasma") +  # nice color scale for density
  labs(title = "Density Scatter Plot",
       x = "Ping",
       y = "Depth (m)",
       color = "Density (#/m³)") +
  theme_minimal()
scatter1


```


